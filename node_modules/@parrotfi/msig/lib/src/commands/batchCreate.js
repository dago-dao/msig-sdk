"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.batchCreateProposals = void 0;
const web3_js_1 = require("@solana/web3.js");
const chalk_1 = __importDefault(require("chalk"));
const base64_js_1 = require("base64-js");
const utils_1 = require("../utils");
/// create configured multisig tx
async function batchCreateProposals(ctx, proposals, smallTransaction, //if encountered error: Transaction too large, use true
drayRun) {
    if (smallTransaction) {
        console.log("use smallTransaction");
    }
    const multisigProg = ctx.multisigProg;
    (0, utils_1.ensureProposalsMemoUnique)(proposals);
    const proposerPubkey = multisigProg.provider.wallet.publicKey;
    const txPubkeys = proposals.map((p) => p.calcTransactionAccount().publicKey);
    const multipleAccounts = await multisigProg.provider.connection.getMultipleAccountsInfo(txPubkeys);
    const multisigState = await multisigProg.account.multisig.fetch(ctx.multisig);
    (0, utils_1.assertProposerIsOwnerOfMultisig)(proposerPubkey, multisigState);
    for (let i = 0; i < proposals.length; i++) {
        const prop = proposals[i];
        if (multipleAccounts[i] && multipleAccounts[i].lamports > 0) {
            console.log(chalk_1.default.green(`ALREADY CREATED: `), prop.memo, chalk_1.default.grey(" => "), prop.calcTransactionAccount().publicKey.toBase58());
            continue;
        }
        await createTx(ctx, proposerPubkey, prop, smallTransaction, drayRun);
    }
}
exports.batchCreateProposals = batchCreateProposals;
async function createTx(ctx, proposerPubkey, proposal, smallTransaction, drayRun) {
    const transaction = proposal.calcTransactionAccount();
    const instrs = await proposal.createInstr(ctx);
    const ix = instrs.multisigInstr;
    console.log("create tx: ", transaction.publicKey.toBase58());
    (0, utils_1.betterPrintObjectWithPublicKey)(proposal);
    (0, utils_1.printKeys)(ix.keys);
    console.log("local created instr in base64: ", (0, base64_js_1.fromByteArray)(ix.data));
    if (drayRun) {
        console.log("multisig instr:");
        console.log("programId:", ix.programId.toBase58());
        console.log("data:", ix.data);
        console.log("accounts:");
        (0, utils_1.printKeys)(ix.keys);
        return;
    }
    const txSize = 100 + 34 * ix.keys.length + ix.data.length;
    if (smallTransaction) {
        //first send prepare instructions
        const prepareTxid = await ctx.multisigProg.provider.send(new web3_js_1.Transaction().add(...(instrs.prepare?.instructions || []), await ctx.multisigProg.account.transaction.createInstruction(transaction, txSize)), [...(instrs.prepare?.signers || []), transaction]);
        console.log("prepare txid:", prepareTxid);
        for (;;) {
            console.log("check transaction account created successfully");
            const transactionAccountSolBalance = await ctx.multisigProg.provider.connection.getBalance(transaction.publicKey);
            if (transactionAccountSolBalance > 0) {
                console.log("wait 3s to ensure transaction created");
                await (0, utils_1.sleep)(3 * 1000);
                break;
            }
        }
        //then send create multisig transaction instruction
        const txid = await ctx.multisigProg.rpc.createTransaction(ix.programId, ix.keys, ix.data, {
            accounts: {
                multisig: ctx.multisig,
                transaction: transaction.publicKey,
                proposer: proposerPubkey,
                rent: web3_js_1.SYSVAR_RENT_PUBKEY,
            },
        });
        console.log("create multisig txid:", txid);
    }
    else {
        const txid = await ctx.multisigProg.rpc.createTransaction(ix.programId, ix.keys, ix.data, {
            accounts: {
                multisig: ctx.multisig,
                transaction: transaction.publicKey,
                proposer: proposerPubkey,
                rent: web3_js_1.SYSVAR_RENT_PUBKEY,
            },
            instructions: [
                ...(instrs.prepare?.instructions || []),
                await ctx.multisigProg.account.transaction.createInstruction(transaction, txSize),
            ],
            signers: [...(instrs.prepare?.signers || []), transaction],
        });
        console.log("create multisig txid:", txid);
    }
}
//# sourceMappingURL=batchCreate.js.map